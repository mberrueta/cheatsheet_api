---
:description: Generated sheet for r2
:tags:
- community
:shortcuts:
  :defaults:
    Command Line options: "\t-L: List of supported IO plugins\n\n\t-q: Exit after
      processing commands\n\n\t-w: Write mode enabled\n\n\t-i: Interprets a r2 script\n\n\t-A:
      Analize executable at load time (xrefs, etc)\n\n\t-n: Bare load. Do not load
      executable info as the entrypoint\n\n\t-c'cmds': Run r2 and execute commands
      (eg: r2 -wqc'wx 3c @ main')\n\n\t-p: Creates a project for the file being analyzed
      (CC add a comment when opening a file as a project)\n\n\t-: Opens r2 with the
      malloc plugin that gives a 512 bytes memory area to play with (size can be changed);
      Similar to r2 malloc://512\n\n-----------------------------------------------------------------------------------------------------------------------------\n\n"
    Configuration properties: "\te: Returs configuration properties\n\t\n\te <property>:
      Checks a specific property:\n    \t\te asm.tabs => false\n\n\te <property>=<value>:
      Change property value\n    \t\te asm.arch=ppc\n\n\te? help about a configuration
      property\n    \t\te? cmd.stack\n\n\t\n\t\n\t# Show comments at right of disassembly
      if they fit in screen\n\t\te asm.cmtright=true\n\n\t# Shows pseudocode in disassembly.
      Eg mov eax, str.ok = > eax = str.ok\n\t\te asm.pseudo = true\n\n\t# Display
      stack and register values on top of disasembly view (visual mode)\n\t\te cmd.stack
      = true\n\n\t# Solarized theme\n\t\teco solarized\n\n\t# Use UTF-8 to show cool
      arrows that do not look like crap :)\n\t\te scr.utf8 = true\n\n-----------------------------------------------------------------------------------------------------------------------------\n\n"
    Basic Commands: "\n\t; Command chaining: x 3;s+3;pi 3;s+3;pxo 4;\n    \n\t| Pipe
      with shell commands: pd | less\n    \n\t! Run shell commands: !cat /etc/passwd\n
      \   \n\t!! Escapes to shell, run command and pass output to radare buffer\n
      \   \t\t\n\t\tNote: \tThe double exclamation mark tells radare to skip the plugin
      list to find an IO plugin handling this\n\t\t\tcommand to launch it directly
      to the shell. A single one will walk through the io plugin list.\n\n    \t`
      Radare commands: wx `!ragg2 -i exec`\n    \n\t~ grep\n    \n\t~! grep -v\n    \n\t~[n]
      grep by columns afl~[0]\n\n    \t~:n grep by rows afl~:0\n\t\n\t<command>~..
      less/more mode\n\n\t+-------------------------------------------------------------------\n\t\n\tpi~mov,eax
      \           ; lines with mov or eax\n    \tpi~mov&eax            ; lines with
      mov and eax\n    \tpi~mov,eax:6          ; 6 first lines with mov or eax\n    \tpd
      20~call[0]:0       ; grep first column of the first row matching 'call'\n\t\n\t+-------------------------------------------------------------------\n\n\t.cmd
      Interprets command output\n\t\n\t+-------------------------------------------------------------------\n\t\n\tis*
      prints symbolos\n\t.is* interprets output and define the symbols in radare (normally
      they are already loaded if r2 was not invoked with -n)\n\t\n\t+-------------------------------------------------------------------\n\t\n\t..
      repeats last commands (same as enter \\n)\n    \t\n\t( Used to define and run
      macros\n    \n\t$ Used to define alias\n    \n\t$$: Resolves to current address\n
      \   \t\n\tOffsets (@) are absolute, we can use $$ for relative ones @ $$+4\n
      \   \n\t? Evaluate expression\n\t+-------------------------------------------------------------------\n\n\t[0x00000000]>
      ? 33 +2\n\t35 0x23 043 0000:0023 35 00100011 35.0 0.000000\n\tNote: | and &
      need to be escaped\n\n\t+-------------------------------------------------------------------\n\n\t?$?
      Help for variables used in expressions\n    \n\t$$: Here\n    \n\t$s: File size\n
      \   \n\t$b: Block size\n    \n\t$l: Opcode length\n    \n\t$j: When $$ is at
      a jmp, $j is the address where we are going to jump to\n    \n\t$f: Same for
      jmp fail address\n\t\n\t$m: Opcode memory reference (e.g. mov eax,[0x10] =>
      0x10)\n    \n\t??? Help for ? command\n    \n\t?i Takes input from stdin. Eg
      ?i username\n    \n\t?? Result from previous operations\n    \n\t?s from to
      [step]: Generates sequence from to every\n    \n\t?p: Get physical address for
      given virtual address\n    \n\t?P: Get virtual address for given physical one\n
      \   \n\t?v Show hex value of math expr\n\n\t+-------------------------------------------------------------------\n\n\t?v
      0x1625d4ca ^ 0x72ca4247 = 0x64ef968d\n\t?v 0x4141414a - 0x41414140  = 0xa\n\n\t+-------------------------------------------------------------------\n\n\t?l
      str: Returns the length of string\n    \n\t@@: Used for iteractions\n\n\t+-------------------------------------------------------------------\n\n\twx
      ff @@10 20 30      Writes ff at offsets 10, 20 and 30\n\twx ff @@`?s  1 10 2`
      \ Writes ff at offsets 1, 2 and 3\n\twx 90 @@ sym.*        Writes a nop on every
      symbol\n\n\t+-------------------------------------------------------------------\n\n"
    Positioning: "\n\ts address: Move cursor to address or symbol\n\t\n\ts-5 (5 bytes
      backwards)\n\t\n\ts- undo seek\n\n\ts+ redo seek\n\n"
    Block Size: "\n\tb size: Change block size\n\n"
    Analyze: "\t\n\taa: Analyze all (fcns + bbs) same that running r2 with -A\n\n\tahl
      <length> <range>: fake opcode length for a range of bytes\n\t\n\tad: Analyze
      data\n\n\tad@rsp (analize the stack)\n\n\t+ Normal mode\n\t\t\n\t\taf: Analyze
      functions\n\n\t\tafl: List all functions\n    \t\t\tnumber of functions: afl~?\n\n\t\tafi:
      Returns information about the functions we are currently at\n\n\t\tafr: Rename
      function: structure and flag\n\t\n\t\tafr off: Restore function name set by
      r2\n\n\t\tafn: Rename function\n\t\t\n\t\tafn strlen 0x080483f0\n\n\t\taf-:
      Removes metadata generated by the function analysis\n\n\t\taf+: Define a function
      manually given the start address and length\n\t\t\taf+ 0xd6f 403 checker_loop\n\n\t\taxt:
      Returns cross references to (xref to)\n\n\t\taxf: Returns cross references from
      (xref from)\n\t\n\t+ Visual mode\n\n\t\td, f: Function analysis\n\n\t\td, u:
      Remove metadata generated by function analysis\n\n\t+ Opcode analysis\n\t\t\n\t\tao
      x: Analize x opcodes from current offset\n\n\t\ta8 bytes: Analize the instruction
      represented by specified bytes\n\n"
    Information: "\n\t\tiI: File info\n\n\t\tiz: Strings in data section\n\n\t\tizz:
      Strings in the whole binary\n\t\n\t\tiS: Sections\n\t\t\tiS~w returns writable
      sections\n\n\t\tis: Symbols\n\t\t\tis~FUNC exports\n\t\t\n\t\til: Linked libraries\n\n\t\tii:
      Imports\n\n\t\tie: Entrypoint\n\n\t+ Mitigations\n\n\t\ti~pic : check if the
      binary has position-independent-code\n\t\n\t\ti~nx : check if the binary has
      non-executable stack\n\n\t\ti~canary : check if the binary has canaries\n\n"
    Print: "\n\tpsz n @ offset: Print n zero terminated String\n\n\tpx n @ offset:
      Print hexdump (or just x) of n bytes\n\n\tpxw n @ offset: Print hexdump of n
      words\n\t\tpxw size@offset  prints hexadecimal words at address\n\n\tpd n @
      offset: Print n opcodes disassambled\n\n\tpD n @ offset: Print n bytes disassembled\n\n\tpi
      n @ offset: Print n instructions disassambeled (no address, XREFs, etc. just
      instrunctions)\n\n\tpdf @ offset: Print disassembled function\n\t\tpdf~XREF
      (grep: XREFs)\n\t\tpdf~call (grep: calls)\n\n\tpcp n @ offset: Print n bytes
      in python string output.\n\t\tpcp 0x20@0x8048550\n\t\timport struct\n\t\tbuf
      = struct.pack (\"32B\",\n    \t\t\t0x55,0x89,0xe5,0x83,0xzz,0xzz,0xzz,0xzz,0xf0,0x00,0x00,\n\t\t\t0x00,0x00,0xc7,0x45,0xf4,0x00,0x00,0x00,0x00,0xeb,0x20,\n\t\t\t0xc7,0x44,0x24,0x04,0x01,0x00,0x00,0x00,0xzz,0xzz)\n\n\tp8
      n @ offset: Print n bytes (8bits) (no hexdump)\n\t\n\tpv: Print file contents
      as IDA bar and shows metadata for each byte (flags , ...)\n\n\tpt: Interpret
      data as dates\n\n\tpf: Print with format\n\n\tpf.: list all formats\n\n\tp=:
      Print entropy ascii graph\n\n"
    Write: "\n\twx: Write hex values in current offset\n    \t\twx 123456\n    \t\twx
      ff @ 4\n\n\twa: Write assembly\n    \t\twa jnz 0x400d24\n\n\twc: Write cache
      commit\n\n\twv: Writes value doing endian conversion and padding to byte\n\n\two[x]:
      Write result of operation\n    \t\twow 11223344 @102!10\n        \t\twrite looped
      value from 102 to 102+10\n        \t\t0x00000066  1122 3344 1122 3344 1122 0000
      0000 0000\n    \n\twox 0x90\n        \tXOR the current block with 0x90. Equivalent
      to wox 0x90 $$!$b (write from current position, a whole block)\n    \t\n\twox
      67 @4!10\n        \tXOR from offset 4 to 10 with value 67\n\n\twf file: Writes
      the content of the file at the current address or specified offset (ASCII characters
      only)\n\n\twF file: Writes the content of the file at the current address or
      specified offset\n\n\twt file [sz]: Write to file (from current seek, blocksize
      or sz bytes)\n    \t\tEg: Dump ELF files with wt @@ hit0* (after searching for
      ELF headers: \\x7fELF)\n\n\twoO 41424344 : get the index in the De Bruijn Pattern
      of the given word\n\n"
    Flags: "\n\tf: List flags\n\n\tf label @ offset: Define a flag `label` at offset\n
      \   \t\tf str.pass_len @ 0x804999c\n\n\tf -label: Removes flag\n\n\tfr: Rename
      flag\n\n\tfd: Returns position from nearest flag (looking backwards). Eg =>
      entry+21\n\n\tfs: Show all flag spaces\n\n\tfs flagspace: Change to the specified
      flag space\n\n\tfe loop and create numbered flags:\n\t\t\n\t\t1. fs demo_flagspace\n\t\t2.
      fe demo_flagspace @@=`pdf~jne[1]`\n\n"
    Yank & Paste: "\n\ty n: Copies n bytes from current position\n\n\ty: Shows yank
      buffer contentent with address and length where each entry was copied from\n\n\typ:
      Prints yank buffer\n\n\tyy offset: Paste the contents of the yank buffer at
      the specified offset\n\n\tyt n target @ source: Yank to. Copy n bytes fromsource
      to target address\n\n"
    Visual Mode: "\n\tq: Exits visual mode\n\n\thjkl: move around (or HJKL) (left-down-up-right)\n\n\to:
      go/seek to given offset\n\n\t?: Help\n\n\t.: Seek EIP\n\n\t<enter>: Follow address
      of the current jump/call\n\n\t:cmd: Enter radare commands. Eg: x @ esi\n\n\td[f?]:
      Define cursor as a string, data, code, a function, or simply to undefine it.\n
      \   \t\tdr: Rename a function\n    \t\tdf: Define a function\n\n\tv: Get into
      the visual code analysis menu to edit/look closely at the current function.\n\n\tp/P:
      Rotate print (visualization) modes\n    \t\thex, the hexadecimal view\n    \t\tdisasm,
      the disassembly listing\n        \t\tUse numbers in [] to follow jump\n        \t\tUse
      \"u\" to go back\n    \t\t\n\t\tdebug, the debugger\n    \t\twords, the word-hexidecimal
      view\n    \t\tbuf, the C-formatted buffer\n    \t\tannotated, the annotated
      hexdump.\n\n\tc: Changes to cursor mode or exits the cursor mode\n    \t\tselect:
      Shift+[hjkl]\n    \t\ti: Insert mode\n    \t\ta: assembly inline\n    \t\tA:
      Assembly in visual mode\n    \t\ty: Copy\n    \t\tY: Paste\n    \t\tf: Creates
      a flag where cursor points to\n    \t\t<tab> in the hexdump view to toggle between
      hex and strings columns\n\n\tV: View ascii-art basic block graph of current
      function\n\n\tW: WebUI\n\n\tx, X: XREFs to current function. (\"u\" to go back)\n\n\tt:
      track flags (browse symbols, functions..)\n\n\tgG: Begging or end of file\n\n\tHUD\n
      \   \t\t_ Show HUD\n    \t\tbackspace: Exits HUD\n    \t\tWe can add new commands
      to HUD in: radare2/shlr/hud/main\n\n\t;[-]cmt: Add/remove comment\n\n\tm<char>:
      Define a bookmark\n\n\t'<char>: Go to previously defined bookmark\n\n"
    ROP: "\t\n\t/R opcodes: Search opcodes\n    \t\n\t/R pop,pop,ret\n\t\n\t/Rl opcodes:
      Search opcodes and print them in linear way\n\t\n\t/Rl jmp eax,call ebx\n\n\t/a:
      Search assembly\n    \t\n\t/a jmp eax\n\n\tpda: Returns a library of gadgets
      that can be use. These gadgets are obtained by disassmbling byte per byte instead
      of obeying to opcode leng\n\n\te search.roplen = 4  (change the depth of the
      search, to speed-up the hunt)\n\n"
    Searching: "\n\t/ bytes: Search bytes\n    \t\t\\x7fELF\n\n\t+-------------------------------------------------------------------\n\n\tpush
      ebp\n\tmov ebp, esp\n\n\tOpcodes: 5589e5\n\n\t/x 5589e5\n\t\t[# ]hits: 54c0f4
      < 0x0804c600  hits = 1\n    \t\t0x08049f70 hit0_0 5589e557565383e4f081ec\n    \t\t0x0804c31a
      hit0_1 5589e583ec18c704246031\n    \t\t0x0804c353 hit0_2 5589e583ec1889442404c7\n
      \   \t\t0x0804c379 hit0_3 5589e583ec08e87cffffff\n    \t\t0x0804c3a2 hit0_4
      5589e583ec18c70424302d\n\n\t\tpi 5 @@hit* (Print 5 first instructions of every
      hit)\n\n\t+-------------------------------------------------------------------\n\n\tIts
      possible to run a command for each hit. Use the cmd.hit property:\n\n\t\te cmd.hit=px\n\n"
    Comments and defines: "\n\tCd [size]: Define as data\n\n\tC- [size]: Define as
      code\n\n\tCs [size]: Define as String\n\n\tCf [size]: Define as struct\n    \t\tWe
      can define structures to be shown in the disassmbly\n\n\tCC: List all comments
      or add a new comment in console mode\n    \t\tC* Show all comments/metadata\n
      \   \t\tCC <comment> add new comment\n    \t\tCC- remove comment\n\n"
    Magic files: "\n\tpm: Print Magic files analysis\n    \t\t[0x00000000]> pm\n    \t\t0x00000000
      1 ELF 32-bit LSB executable, Intel 80386, version 1\n\n\t/m [magicfile]: Search
      magic number headers with libmagic\n\n\tsearch.align\n\tsearch.from (0 = beginning)\n\tsearch.to
      (0 = end)\n\tsearch.asmstr\n\tsearch.in\n\n"
    Yara: "\t\n\t:yara scan\n\n"
    Zignatures: "\n\tzg <language> <output file>: Generate signatures\n\t\teg: zg
      go go.z\n\n\tRun the generated script to load signatures\n    \t\teg: . go.z\n\n\tz:
      To show signatures loaded:\n\n\t+-------------------------------------------------------------------\n\t\n\tr2-(pid2)>
      pd 35 @ 0x08049adb-10\n\t|          0x08049adb   call fcn.0805b030\n\t|             fcn.0805b030(unk,
      unk, unk, unk) ; sign.sign.b.sym.fmt.Println\n\t|          0x08049ae0   add
      esp, 0xc\n\t|          0x08049ae3   call fcn.08095580\n\n\t+-------------------------------------------------------------------\n\n"
    Compare Files: "\n\tr2 -m 0xf0000 /etc/fstab    ; Open source file\n\t\n\to /etc/issue
      \               ; Open file2 at offset 0\n\t\n\to                           ;
      List both files\n\n\tcc offset: Diff by columns between current offset address
      and \"offset\"\n\n"
    Graphs: "\n\t+ Basic block graphs\n\t\t\n\t\taf: Load function metadata\n\n\t\tag
      $$ > a.dot: Dump basic block graph to file\n\n\t\tag $$ | xdot: Show current
      function basic block graph\n\n\t+ Call graphs\n\n\t\taf: Load function metadata\n\n\t\tagc
      $$ > b.dot: Dump basic block graph to file\n\n\t+ Convert .dot in .png\n\n\t\tdot
      -Tpng -o /tmp/b.png b.dot\n\n\t+ Generate graph for file\n\n\t\tradiff2 -g main
      crackme.bin crackme.bin > /tmp/a\n\t\txdot /tmp/a\n\n"
    Debugger: "\n\t+ Start r2 in debugger mode. r2 will fork and attach\n\t\t\n\t\tr2
      -d [pid|cmd|ptrace] (if command contains spaces use quotes: r2 -d \"ls /\")\n\t\t\n\t\tptrace://pid
      (debug backend does not notice, only access to mapped memory)\n\n\t+ Pass arguments\n\t\t\n\t\tr2
      -d rarun2 program=pwn1 arg1=$(python exploit.py)\n\n\t+ Pass stdin\n\t\t\n\t\tr2
      -d rarun2 program=/bin/ls stdin=$(python exploit.py)\n\n\t+ Commands\n\n\t\tdo:
      Reopen program\n\n\t\tdp: Shows debugged process, child processes and threads\n\n\t\tdc:
      Continue\n\n\t\tdcu <address or symbol>: Continue until symbol (sets bp in address,
      continua until bp and remove bp)\n\n\t\tdc[sfcp]: Continue until syscall(eg:
      write), fork, call, program address (To exit a library)\n\n\t\tds: Step in\n\n\t\tdso:
      Step out\n\n\t\tdss: Skip instruction\n\n\t\tdr register=value: Change register
      value\n\n\t\tdr(=)?: Show register values\n\n\t\tdb address: Sets a breakpoint
      at address\n    \t\t\tdb sym.main add breakpoint into sym.main\n    \t\t\tdb
      0x804800 add breakpoint\n    \t\t\tdb -0x804800 remove breakpoint\n\n\t\tdsi
      (conditional step): Eg: \"dsi eax==3,ecx>0\"\n\n\t\tdbt: Shows backtrace\n\n\t\tdrr:
      Display in colors and words all the refs from registers or memory\n\n\t\tdm:
      Shows memory map (* indicates current section)\n    \t\t\t[0xb776c110]> dm\n
      \   \t\t\tsys 0x08048000 - 0x08062000 s r-x /usr/bin/ls\n    \t\t\tsys 0x08062000
      - 0x08064000 s rw- /usr/bin/ls\n    \t\t\tsys 0xb776a000 - 0xb776b000 s r-x
      [vdso]\n    \t\t\tsys 0xb776b000 * 0xb778b000 s r-x /usr/lib/ld-2.17.so\n    \t\t\tsys
      0xb778b000 - 0xb778d000 s rw- /usr/lib/ld-2.17.so\n    \t\t\tsys 0xbfe5d000
      - 0xbfe7e000 s rw- [stack]\n\n\t+ To follow child processes in forks (set-follow-fork-mode
      in gdb)\n\n\t\tdcf until a fork happen then use dp to select what process you
      want to debug.\n\n\t+ PEDA like details\n\t\t\n\t\tdrr;pd 10@-10;pxr 40@esp\n\n\t+
      Debug in visual mode\n\n\t\ttoggl breakpoints with F2\n\t\tsingle-step with
      F7 (s)\n\t\tstep-over with F8 (S)\n\t\tcontinue with F9\n\n"
    WebGUI: "\t\n\t=h: Start the server\n\t=H: Start server and browser\n\n"
    rax2 - Base Conversion: "\n\t-e: Change endian\n\t\n\t-k: random ASCII art to
      represent a number/hash. Similar to how SSH represents keys\n\t\n\t-s: ASCII
      to hex\n    \t\trax2 -S hola (from string to hex)\n    \t\trax2 -s 686f6c61
      (from hex to string)\n\n\t-S: binary to hex (for files)\n\t\n\t-N: pack an integer
      \n\t\trax2 -N 0x1234 # \\x34\\x12\\x00\\x00\n\n"
    rahash2 - Entropy, hashes and checksums: "\n\t-a: Specify the algorithm\n\n\t-b
      XXX: Block size\n\n\t-B: Print all blocks\n\n\t-a entropy: Show file entropy
      or entropy per block (-B -b 512 -a entropy)\n\t\n\t+ Rot13 with rahash2\n\t\trahash2
      -E rot -S s:13 -s ‘Hello\\n’\n\n"
    radiff2 - File diffing: "\n\t-s: Calculate text distance from two files.\n\n\t-d:
      Delta diffing (For files with different sizes. Its not byte per byte)\n\n\t-C:
      Code diffing (instead of data)\n\n\t+-------------------------------------------------------------------\n\n\tDiff
      original and patched on x86_32, using graphdiff algorithm\n    \t\tradiff2 -a
      x86 -b32 -C original patched\n\n\tShow differences between original and patched
      on x86_32\n    \t\tradiff2 -a x86 -b32 original patched :\n\n\t+-------------------------------------------------------------------\n\n"
    rasm2 - Assembly/Disasembly: " \n\t-L: Supported architectures\n\n\t-a arch instruction:
      Sets architecture\n    \t\trasm2 -a x86 'mov eax,30' => b81e000000\n\n\t-b tam:
      Sets block size\n\n\t-d: Disassembly\n    \t\trasm2 -d b81e000000 => mov eax,
      0x1e\n\n\t-C: Assembly in C output\n    \t\trasm2 -C 'mov eax,30' => \"\\xb8\\x1e\\x00\\x00\\x00\"\n\n\t-D:
      Disassemble showing hexpair and opcode\n    \t\trasm2 -D b81e0000 => 0x00000000
      \  5               b81e000000  mov eax, 0x1e\n\n\t-f: Read data from file instead
      of ARG.\n\n\t-t: Write data to file\n\n\t+ Disassemble shellcode from hex stdin\n\n\t+-------------------------------------------------------------------\n\n\techo
      -n \"31c048bbd19d9691d08c97ff48f7db53545f995257545eb03b0f05\" | rasm2 -a x86
      -b 64 -d -\n\t\txor eax, eax\n\t\tmovabs rbx, 0xff978cd091969dd1\n\t\tneg rbx\n\t\tpush
      rbx\n\t\tpush rsp\n\t\tpop rdi\n\t\tcdq\n\t\tpush rdx\n\t\tpush rdi\n\t\tpush
      rsp\n\t\tpop rsi\n\t\tmov al, 0x3b\n\t\tsyscall\n\n\t+-------------------------------------------------------------------\n\n"
    rafind2 - Search: "\n\t-Z: Look for Zero terminated strings\n\n\t-s str: Look
      for specifc string\n\n\t-X: Hex dump around output\n\n\t+ Search \"/bin/sh\"
      in libc\n\n\t\trafind2 -X -s \"/bin/sh\" /usr/lib/libc.so.6\n\n"
    ragg2 - Shellcode generator, C/opcode compiler: "\n\tP: Generate De Bruijn patterns\n
      \   \t\tragg2 -P 300 -r\n\n\t-a arch: Configure architecture\n\n\t-b bits: Specify
      architecture bits (32/64)\n\n\t-i shellcode: Specify shellcode to generate\n\n\t-e
      encoder: Specify encoder\n\n\t+ ragg2-cc: Generate shellcode from c\n\n\t+ Generate
      a x86, 32 bits exec shellcode\n    \t\tragg2 -a x86 -b 32 -i exec\n\n"
    'rabin2 - Executable analysis: symbols, imports, strings': "\n\t-I: Executable
      information\n\n\t-C: Returns classes. Useful to list Java Classes\n\n\t-l: Dynamic
      linked libraries\n\n\t-s: Symbols\n\n\t-z: Strings\n\n"
    rarun2 - Launcher to run programs with different environments, args, stdin, permissions, fds: "\n\tr2
      -b 32 -d rarun2 program=pwn1 arg1=$(ragg2 -P 300 -r) : runs pwn1 with a De Bruijn
      Pattern as first argument, inside radare2's debugger, and force 32 bits\n\tr2
      -d rarun2 program=/bin/ls stdin=$(python exploit.py) : runs /bin/ls with the
      output of exploit.py directed to stdin\n\n"
    ESIL emulation: "\n\t1) aei: Initialize ESIL VM\n\t\n\t2) aeim: Assign ESIL stack\n\t\taeim
      0xffffd000 0x1000 stack\n\t\n\t3) aeip: Program counter to current seek\n\n\t4)
      e io.cache=true: Enable caching read/write of virtual memory (Important if self
      modifying code)\n\n\t5) aes: Single stepping in emulation mode\n\n\t+ Toggle
      IL representation via O in Visual Mode\n\n"
    ESIL Linear emulation: "\n\tFind all references to curr. address using linear
      esil emulation on all imports.\n\t\t\n\t\t/re$$@@ sym.imp.*\n\n"
    ESIL IL Representation: "\n\top \tesil\n\t------------\n\tmov \t=\n\tmul \t*\n\tdiv
      \t/\n\tand \t&\n\tneg\t!\n\tread \t[]\n\tif \t?{\n\tadd\t+\n\tsub\t-\n\txor
      \t^\n\tor\t|\n\tcmp\t==\n\twrite\t=[]\n\t\n\t+ prefix is %\n\t+ carry from bit
      x -> %cx\n\t+ borrow from bit x -> %bx\n\t+ zero-flag -> %z\n\t+ parity of dst
      -> %p\n\t+ sign-flag -> %s\n\t+ overflow-flag -> %o\n\n\t+ BREAK - Stop parsing
      and emulate next instruction\n\t+ LOOP - restart emulation of instruction\n\t+
      GOTO n - jump to n\n\t+ TODO - stop emulation and eprintf(\"TDOD %s\", ins)\n\n\tx86\t\t\tESIL\n\t------------------------------------------------------\n\tmov
      eax, ebx\t\tebx,eax,=\n\tjz 0xaabbccdd\t\tzf,?{,0xaabbccdd,eip,=,}\n\tcmp ecx,edx\t\tedx,ecx,==,%z,zf,=,%b32,cf,=,%p,pf,=,%s,sf,=\n\tpush
      ebp\t\t4,esp,-=ebp,esp,=[4]\n\n\t+ ESIL Doc\n\t\thttps://github.com/radare/radare2book/blob/master/esil.md\n\t\n"
    r2pipe commands: "\n\t+ Invoke r2pipe script via r2 cmdline\n\t\t\n\t\t[0x00000000]>
      #!pipe node script.js\n\t\t[0x00000000]> #!pipe python script.py\n\n\t+ Good
      collection:\n\t\thttps://radare.org/get/r2pipe-nn2015.pdf\n\t\thttps://github.com/jpenalbae/r2-scripts\n"
    Parsing ELF: "\t\n\t!!! open with r2 -nn \n\n\t+ Parse 9 program headers (elf_phdr)
      from curr. seek plus offset 0x40 with temporary block size 0x200 in less mode
      (~..)\n\n\t\t[0x00000000]> pf 9? (elf_phdr)phdr @ $$+0x40!0x200~..\n\t\n"
    pf Templates: "\t\n\t+ Generate templates for structs/enums with td command\n\n\t\t\"td
      enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\"\n\n\thttps://github.com/Maijin/r2-pf-templates/\n\n\t+
      Cast data @ <addr> to <type> and print it\t\t\n\t\t\n\t\ttp <type>  = <address>\n\n"
    r2scapy: "\n\tr2 -i r2scapy.py dump.bin\n\t\t[0x00000000]> scapy DNS 0x81de3c
      48\n\t\tDNS(aa=1L, qr=1L, an=DNSRR(rclass=32769, ttl=120, rrname='flashair.local.',
      rdata='192.168.0.1', type=1), ad=0L, nscount=0, qdcount=1, ns=None, tc=0L, rd=1L,
      arcount=0, ar=None, opcode=0L, ra=0L, cd=0L, z=0L, rcode=0L, id=0, ancount=1,
      qd=DNSQR(qclass=32769, qtype=255, qname='flashair.local.'))\n\t\n\t+ generate
      packets with scapy\n\t\t>>> from scapy.all import *\n\t\t>>> sr1(IP(dst=\"8.8.8.8\")/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname=\"www.thepacketgeek.com\")),verbose=0)\n\n"
    r2m2 -Miasm  Intermediate Representation Plugin: "\t\n\t+ Assemble and disassemble
      MIPS32 using rasm2\n\n\t\tr2m2$ export R2M2_ARCH=mips32l; rasm2 -a r2m2 'addiu
      a0, a1, 2' |rasm2 -a r2m2 -d -\n\t\tADDIU      A0, A1, 0x2\n\n\t+ Disassemble
      random MSP430 instructions in r2\n\n\t\tr2m2$ R2M2_ARCH=msp430 r2 -a r2m2 -qc
      'woR; pd 5' -\n            \t\t0x00000000      07fa           and.w      R10,
      R7\n            \t\t0x00000002      47ad           dadd.b     R13, R7\n            \t\t0x00000004
      \     f05e0778       add.b      @R14+, 0x7807(PC)\n            \t\t0x00000008
      \     f46d81ed       addc.b     @R13+, 0xED81(R4)\n            \t\t0x0000000c
      \     3fdc           bis.w      @R12+, R15\n\t+ Assemble MIPS32 using rasm2
      and display the call graph using r2\n\n\t\tr2m2$ R2M2_ARCH=mips32b rasm2 -a
      r2m2 'j 0x4; nop' -B > j_nop.bin\n\n\t\tr2m2$ R2M2_ARCH=mips32b r2 -a r2m2 -qc
      'pd 2' j_nop.bin\n        \t\t,=< 0x00000000      0c000001       JAL        0x4\n
      \      \t\t\t`-> 0x00000004      00000000       NOP\n\n"
    bin carving with r2: "\n\t+ Open raw dump\n\t\t\n\t\tr2 -n dump.bin\n\t\n\t+ Searching
      for  magic\n\t\t\n\t\t[0x00000000]> / \\x7fELF\n\t\tSearching 4 bytes from 0x00000000
      to 0x0000002d: 7f 45 4c 46\n\t\t0x00001340 hit0_0\n\t\t0x00001744 hit0_1\n\t\t...\n\n\t+
      Dump 1M with at several hits\n\n\t\t[0x00000000]> b 1M\n\t\t[0x00000000]> wt
      @@ hit0*\n\n\t+ Automate it\n\t\t\n\t\t$ for a in dump.* ; do\n\t\tsz=`rabin2
      -Z $a`     # get RBin.filesize\n\t\tr2 -wnqc\"r $sz\" $a  # resize file\n\t\tdone\n\n\thttp://radare.today/posts/carving-bins/\n\n"
    r4ge - symbolic execution: "\t+ https://github.com/gast04/r4ge\n\n\tUsage: https://asciinema.org/a/155856\n\n"
    r2wiki -Macro for using wiki in commandline: "\t\n\t+ https://github.com/securisec/r2wiki\n\n\t$wiki
      \"query string\"\n"
